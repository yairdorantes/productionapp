{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Extension} */\n\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {boolean|undefined} */\n\n  let inHead;\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  let inRow;\n  /** @type {number|undefined} */\n\n  let contentStart;\n  /** @type {number|undefined} */\n\n  let contentEnd;\n  /** @type {number|undefined} */\n\n  let cellStart;\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow;\n\n  while (++index < events.length) {\n    const token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        assert(contentStart, 'expected `contentStart` to be defined if `contentEnd` is');\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        const text = {\n          type: types.chunkText,\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: constants.contentTypeText\n        };\n        assert(contentStart, 'expected `contentStart` to be defined if `contentEnd` is');\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== types.whitespace))) {\n      const cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<Align>} */\n\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  let hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    assert(!markdownLineEndingOrSpace(code), 'expected non-space');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    assert(code === codes.verticalBar, 'expected `|`');\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit(types.whitespace);\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === codes.eof || code === codes.verticalBar || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === codes.backslash ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    const originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit(types.whitespace);\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === codes.eof) {\n      return tableClose(code);\n    }\n\n    assert(markdownLineEnding(code), 'expected eol');\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, types.linePrefix, constants.tabSize), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    assert(code === codes.verticalBar, 'expected `|`');\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit(types.whitespace);\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === codes.eof || code === codes.verticalBar || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === codes.backslash ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === codes.eof) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, types.linePrefix, constants.tabSize), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return factorySpace(effects, prefixed, types.linePrefix);\n    }\n    /** @type {State} */\n\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === codes.eof || markdownLineEnding(code)) {\n        return nok(code);\n      }\n\n      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {\n        return nok(code);\n      }\n\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === codes.virtualSpace || code === codes.space) {\n      effects.consume(code);\n      size++;\n      return size === constants.tabSize ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","codes","constants","types","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","partial","events","context","index","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","length","token","type","content","start","end","text","chunkText","contentType","contentTypeText","splice","undefined","whitespace","cell","effects","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","verticalBar","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","eof","atRowEndHead","inWhitespaceHead","backslash","inCellContentEscapeHead","originalInterrupt","interrupt","attempt","tokenizeRowEnd","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","dash","push","inFillerDelimiter","colon","afterLeftAlignment","afterRightAlignment","tableClose","check","bodyStart","linePrefix","tabSize","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","lineEnding","prefixed","parser","lazy","now","line","tail","constructs","disable","includes","sliceSerialize","_gfmTableDynamicInterruptHack","size","virtualSpace","space"],"sources":["/home/yair/Desktop/what i delete form project/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {null: {tokenize: tokenizeTable, resolve: resolveTable}}\n}\n\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n  let inHead\n  /** @type {boolean|undefined} */\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n  let inRow\n  /** @type {number|undefined} */\n  let contentStart\n  /** @type {number|undefined} */\n  let contentEnd\n  /** @type {number|undefined} */\n  let cellStart\n  /** @type {boolean|undefined} */\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        assert(\n          contentStart,\n          'expected `contentStart` to be defined if `contentEnd` is'\n        )\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n        const text = {\n          type: types.chunkText,\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: constants.contentTypeText\n        }\n\n        assert(\n          contentStart,\n          'expected `contentStart` to be defined if `contentEnd` is'\n        )\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== types.whitespace)))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n  let hasDash\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    assert(!markdownLineEndingOrSpace(code), 'expected non-space')\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function cellDividerHead(code) {\n    assert(code === codes.verticalBar, 'expected `|`')\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  /** @type {State} */\n  function cellBreakHead(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit(types.whitespace)\n    return cellBreakHead(code)\n  }\n\n  /** @type {State} */\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? inCellContentEscapeHead\n      : inCellContentHead\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeHead(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function atRowEndHead(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {tokenize: tokenizeRowEnd, partial: true},\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n\n  /** @type {State} */\n  function atDelimiterRowBreak(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit(types.whitespace)\n    return atDelimiterRowBreak(code)\n  }\n\n  /** @type {State} */\n  function inFillerDelimiter(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  /** @type {State} */\n  function afterLeftAlignment(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function afterRightAlignment(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === codes.eof) {\n      return tableClose(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {tokenize: tokenizeRowEnd, partial: true},\n        factorySpace(effects, bodyStart, types.linePrefix, constants.tabSize),\n        tableClose\n      )\n    )(code)\n  }\n\n  /** @type {State} */\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  /** @type {State} */\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function cellDividerBody(code) {\n    assert(code === codes.verticalBar, 'expected `|`')\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  /** @type {State} */\n  function cellBreakBody(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit(types.whitespace)\n    return cellBreakBody(code)\n  }\n\n  /** @type {State} */\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? inCellContentEscapeBody\n      : inCellContentBody\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeBody(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === codes.eof) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {tokenize: tokenizeRowEnd, partial: true},\n        factorySpace(\n          effects,\n          rowStartBody,\n          types.linePrefix,\n          constants.tabSize\n        ),\n        tableBodyClose\n      )\n    )(code)\n  }\n\n  /** @type {State} */\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return factorySpace(effects, prefixed, types.linePrefix)\n    }\n\n    /** @type {State} */\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === codes.eof ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1]\n\n      // Indented code can interrupt delimiter and body rows.\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === types.linePrefix &&\n        tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  /** @type {State} */\n  function whitespace(code) {\n    if (code === codes.virtualSpace || code === codes.space) {\n      effects.consume(code)\n      size++\n      return size === constants.tabSize ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}