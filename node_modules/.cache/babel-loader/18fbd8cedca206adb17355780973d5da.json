{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport { ok as assert } from 'uvu/assert';\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\n\nexport function gfmStrikethrough() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let single = options.singleTilde;\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    text: {\n      [codes.tilde]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [codes.tilde]\n    }\n  };\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1; // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index; // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open && // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }; // Opening.\n\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]]; // Between.\n\n            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n\n    index = -1;\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = types.data;\n      }\n    }\n\n    return events;\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      assert(code === codes.tilde, 'expected `~`');\n\n      if (previous === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {\n        return nok(code);\n      }\n\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n    /** @type {State} */\n\n\n    function more(code) {\n      const before = classifyCharacter(previous);\n\n      if (code === codes.tilde) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === constants.attentionSideAfter && Boolean(before);\n      token._close = !before || before === constants.attentionSideAfter && Boolean(after);\n      return ok(code);\n    }\n  }\n}","map":{"version":3,"names":["ok","assert","splice","classifyCharacter","resolveAll","codes","constants","types","gfmStrikethrough","options","single","singleTilde","tokenizer","tokenize","tokenizeStrikethrough","resolveAllStrikethrough","undefined","text","tilde","insideSpan","null","attentionMarkers","events","context","index","length","type","_close","open","_open","end","offset","start","strikethrough","Object","assign","nextEvents","parser","constructs","slice","data","effects","nok","previous","size","code","characterEscape","enter","more","before","consume","token","exit","after","attentionSideAfter","Boolean"],"sources":["/home/yair/Desktop/Programming/what i delete form project/node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfmStrikethrough(options = {}) {\n  let single = options.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {[codes.tilde]: tokenizer},\n    insideSpan: {null: [tokenizer]},\n    attentionMarkers: {null: [codes.tilde]}\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            // Between.\n            splice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            )\n\n            // Closing.\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            splice(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = types.data\n      }\n    }\n\n    return events\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.tilde, 'expected `~`')\n\n      if (\n        previous === codes.tilde &&\n        events[events.length - 1][1].type !== types.characterEscape\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = classifyCharacter(previous)\n\n      if (code === codes.tilde) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open =\n        !after || (after === constants.attentionSideAfter && Boolean(before))\n      token._close =\n        !before || (before === constants.attentionSideAfter && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}