{"ast":null,"code":"var CAN_USE_DOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement); // Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\n\nfunction testPassiveEventListeners() {\n  if (!CAN_USE_DOM) {\n    return false;\n  }\n\n  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n    return false;\n  }\n\n  var supportsPassiveOption = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get: function () {\n        function get() {\n          supportsPassiveOption = true;\n        }\n\n        return get;\n      }()\n    });\n\n    var noop = function noop() {};\n\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {// do nothing\n  }\n\n  return supportsPassiveOption;\n}\n\nvar memoized = void 0;\n\nfunction canUsePassiveEventListeners() {\n  if (memoized === undefined) {\n    memoized = testPassiveEventListeners();\n  }\n\n  return memoized;\n}\n\nfunction normalizeEventOptions(eventOptions) {\n  if (!eventOptions) {\n    return undefined;\n  }\n\n  if (!canUsePassiveEventListeners()) {\n    // If the browser does not support the passive option, then it is expecting\n    // a boolean for the options argument to specify whether it should use\n    // capture or not. In more modern browsers, this is passed via the `capture`\n    // option, so let's just hoist that value up.\n    return !!eventOptions.capture;\n  }\n\n  return eventOptions;\n}\n/* eslint-disable no-bitwise */\n\n/**\n * Generate a unique key for any set of event options\n */\n\n\nfunction eventOptionsKey(normalizedEventOptions) {\n  if (!normalizedEventOptions) {\n    return 0;\n  } // If the browser does not support passive event listeners, the normalized\n  // event options will be a boolean.\n\n\n  if (normalizedEventOptions === true) {\n    return 100;\n  } // At this point, the browser supports passive event listeners, so we expect\n  // the event options to be an object with possible properties of capture,\n  // passive, and once.\n  //\n  // We want to consistently return the same value, regardless of the order of\n  // these properties, so let's use binary maths to assign each property to a\n  // bit, and then add those together (with an offset to account for the\n  // booleans at the beginning of this function).\n\n\n  var capture = normalizedEventOptions.capture << 0;\n  var passive = normalizedEventOptions.passive << 1;\n  var once = normalizedEventOptions.once << 2;\n  return capture + passive + once;\n}\n\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n  if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n    // eslint-disable-next-line no-param-reassign\n    eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n  }\n}\n\nfunction TargetEventHandlers(target) {\n  this.target = target;\n  this.events = {};\n}\n\nTargetEventHandlers.prototype.getEventHandlers = function () {\n  function getEventHandlers(eventName, options) {\n    var key = String(eventName) + ' ' + String(eventOptionsKey(options));\n\n    if (!this.events[key]) {\n      this.events[key] = {\n        handlers: [],\n        handleEvent: undefined\n      };\n      this.events[key].nextHandlers = this.events[key].handlers;\n    }\n\n    return this.events[key];\n  }\n\n  return getEventHandlers;\n}();\n\nTargetEventHandlers.prototype.handleEvent = function () {\n  function handleEvent(eventName, options, event) {\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    eventHandlers.handlers = eventHandlers.nextHandlers;\n    eventHandlers.handlers.forEach(function (handler) {\n      if (handler) {\n        // We need to check for presence here because a handler function may\n        // cause later handlers to get removed. This can happen if you for\n        // instance have a waypoint that unmounts another waypoint as part of an\n        // onEnter/onLeave handler.\n        handler(event);\n      }\n    });\n  }\n\n  return handleEvent;\n}();\n\nTargetEventHandlers.prototype.add = function () {\n  function add(eventName, listener, options) {\n    var _this = this; // options has already been normalized at this point.\n\n\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    ensureCanMutateNextEventHandlers(eventHandlers);\n\n    if (eventHandlers.nextHandlers.length === 0) {\n      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n    }\n\n    eventHandlers.nextHandlers.push(listener);\n    var isSubscribed = true;\n\n    var unsubscribe = function () {\n      function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n\n        isSubscribed = false;\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        var index = eventHandlers.nextHandlers.indexOf(listener);\n        eventHandlers.nextHandlers.splice(index, 1);\n\n        if (eventHandlers.nextHandlers.length === 0) {\n          // All event handlers have been removed, so we want to remove the event\n          // listener from the target node.\n          if (_this.target) {\n            // There can be a race condition where the target may no longer exist\n            // when this function is called, e.g. when a React component is\n            // unmounting. Guarding against this prevents the following error:\n            //\n            //   Cannot read property 'removeEventListener' of undefined\n            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n          }\n\n          eventHandlers.handleEvent = undefined;\n        }\n      }\n\n      return unsubscribe;\n    }();\n\n    return unsubscribe;\n  }\n\n  return add;\n}();\n\nvar EVENT_HANDLERS_KEY = '__consolidated_events_handlers__'; // eslint-disable-next-line import/prefer-default-export\n\nfunction addEventListener(target, eventName, listener, options) {\n  if (!target[EVENT_HANDLERS_KEY]) {\n    // eslint-disable-next-line no-param-reassign\n    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n  }\n\n  var normalizedEventOptions = normalizeEventOptions(options);\n  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\n\nexport { addEventListener };","map":{"version":3,"names":["CAN_USE_DOM","window","document","createElement","testPassiveEventListeners","addEventListener","removeEventListener","Object","defineProperty","supportsPassiveOption","opts","get","noop","e","memoized","canUsePassiveEventListeners","undefined","normalizeEventOptions","eventOptions","capture","eventOptionsKey","normalizedEventOptions","passive","once","ensureCanMutateNextEventHandlers","eventHandlers","handlers","nextHandlers","slice","TargetEventHandlers","target","events","prototype","getEventHandlers","eventName","options","key","String","handleEvent","event","forEach","handler","add","listener","_this","length","bind","push","isSubscribed","unsubscribe","index","indexOf","splice","EVENT_HANDLERS_KEY"],"sources":["/home/yair/Desktop/Programming/what i delete form project/node_modules/consolidated-events/lib/index.esm.js"],"sourcesContent":["var CAN_USE_DOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n// Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\nfunction testPassiveEventListeners() {\n  if (!CAN_USE_DOM) {\n    return false;\n  }\n\n  if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n    return false;\n  }\n\n  var supportsPassiveOption = false;\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      // eslint-disable-next-line getter-return\n      get: function () {\n        function get() {\n          supportsPassiveOption = true;\n        }\n\n        return get;\n      }()\n    });\n    var noop = function noop() {};\n    window.addEventListener('testPassiveEventSupport', noop, opts);\n    window.removeEventListener('testPassiveEventSupport', noop, opts);\n  } catch (e) {\n    // do nothing\n  }\n\n  return supportsPassiveOption;\n}\n\nvar memoized = void 0;\n\nfunction canUsePassiveEventListeners() {\n  if (memoized === undefined) {\n    memoized = testPassiveEventListeners();\n  }\n  return memoized;\n}\n\nfunction normalizeEventOptions(eventOptions) {\n  if (!eventOptions) {\n    return undefined;\n  }\n\n  if (!canUsePassiveEventListeners()) {\n    // If the browser does not support the passive option, then it is expecting\n    // a boolean for the options argument to specify whether it should use\n    // capture or not. In more modern browsers, this is passed via the `capture`\n    // option, so let's just hoist that value up.\n    return !!eventOptions.capture;\n  }\n\n  return eventOptions;\n}\n\n/* eslint-disable no-bitwise */\n\n/**\n * Generate a unique key for any set of event options\n */\nfunction eventOptionsKey(normalizedEventOptions) {\n  if (!normalizedEventOptions) {\n    return 0;\n  }\n\n  // If the browser does not support passive event listeners, the normalized\n  // event options will be a boolean.\n  if (normalizedEventOptions === true) {\n    return 100;\n  }\n\n  // At this point, the browser supports passive event listeners, so we expect\n  // the event options to be an object with possible properties of capture,\n  // passive, and once.\n  //\n  // We want to consistently return the same value, regardless of the order of\n  // these properties, so let's use binary maths to assign each property to a\n  // bit, and then add those together (with an offset to account for the\n  // booleans at the beginning of this function).\n  var capture = normalizedEventOptions.capture << 0;\n  var passive = normalizedEventOptions.passive << 1;\n  var once = normalizedEventOptions.once << 2;\n  return capture + passive + once;\n}\n\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n  if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n    // eslint-disable-next-line no-param-reassign\n    eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n  }\n}\n\nfunction TargetEventHandlers(target) {\n  this.target = target;\n  this.events = {};\n}\n\nTargetEventHandlers.prototype.getEventHandlers = function () {\n  function getEventHandlers(eventName, options) {\n    var key = String(eventName) + ' ' + String(eventOptionsKey(options));\n\n    if (!this.events[key]) {\n      this.events[key] = {\n        handlers: [],\n        handleEvent: undefined\n      };\n      this.events[key].nextHandlers = this.events[key].handlers;\n    }\n\n    return this.events[key];\n  }\n\n  return getEventHandlers;\n}();\n\nTargetEventHandlers.prototype.handleEvent = function () {\n  function handleEvent(eventName, options, event) {\n    var eventHandlers = this.getEventHandlers(eventName, options);\n    eventHandlers.handlers = eventHandlers.nextHandlers;\n    eventHandlers.handlers.forEach(function (handler) {\n      if (handler) {\n        // We need to check for presence here because a handler function may\n        // cause later handlers to get removed. This can happen if you for\n        // instance have a waypoint that unmounts another waypoint as part of an\n        // onEnter/onLeave handler.\n        handler(event);\n      }\n    });\n  }\n\n  return handleEvent;\n}();\n\nTargetEventHandlers.prototype.add = function () {\n  function add(eventName, listener, options) {\n    var _this = this;\n\n    // options has already been normalized at this point.\n    var eventHandlers = this.getEventHandlers(eventName, options);\n\n    ensureCanMutateNextEventHandlers(eventHandlers);\n\n    if (eventHandlers.nextHandlers.length === 0) {\n      eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n\n      this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n    }\n\n    eventHandlers.nextHandlers.push(listener);\n\n    var isSubscribed = true;\n    var unsubscribe = function () {\n      function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n\n        isSubscribed = false;\n\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        var index = eventHandlers.nextHandlers.indexOf(listener);\n        eventHandlers.nextHandlers.splice(index, 1);\n\n        if (eventHandlers.nextHandlers.length === 0) {\n          // All event handlers have been removed, so we want to remove the event\n          // listener from the target node.\n\n          if (_this.target) {\n            // There can be a race condition where the target may no longer exist\n            // when this function is called, e.g. when a React component is\n            // unmounting. Guarding against this prevents the following error:\n            //\n            //   Cannot read property 'removeEventListener' of undefined\n            _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n          }\n\n          eventHandlers.handleEvent = undefined;\n        }\n      }\n\n      return unsubscribe;\n    }();\n    return unsubscribe;\n  }\n\n  return add;\n}();\n\nvar EVENT_HANDLERS_KEY = '__consolidated_events_handlers__';\n\n// eslint-disable-next-line import/prefer-default-export\nfunction addEventListener(target, eventName, listener, options) {\n  if (!target[EVENT_HANDLERS_KEY]) {\n    // eslint-disable-next-line no-param-reassign\n    target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n  }\n  var normalizedEventOptions = normalizeEventOptions(options);\n  return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\n\nexport { addEventListener };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}